{
    "contents" : "#' Aggregate dataset by state\n#' \n#' @param dt data.table\n#' @param year_min integer\n#' @param year_max integer\n#' @param evtypes character vector\n#' @return data.table\n#'\naggregate_by_state <- function(dt, year_min, year_max, evtypes) {\n  replace_na <- function(x) ifelse(is.na(x), 0, x)\n  round_2 <- function(x) round(x, 2)\n  \n  states <- data.table(STATE_NAME=sort(unique(dt$STATE_NAME)))\n  \n  aggregated <- dt %>% filter(YEAR >= year_min, YEAR <= year_max, EVENT_TYPE %in% evtypes) %>%\n    group_by(STATE_NAME) %>%\n    summarise_each(funs(sum), COUNT:CROPS_DAMAGE)\n  \n  # We want all states to be present even if nothing happened\n  left_join(states,  aggregated, by = \"STATE_NAME\") %>%\n    mutate_each(funs(replace_na), FATALITIES:CROPS_DAMAGE) %>%\n    mutate_each(funs(round_2), PROPERTY_DAMAGE, CROPS_DAMAGE)    \n}\n\n#' Aggregate dataset by year\n#' \n#' @param dt data.table\n#' @param year_min integer\n#' @param year_max integer\n#' @param evtypes character vector\n#' @return data.table\n#'\naggregate_by_year <- function(dt, year_min, year_max, evtypes) {\n  round_2 <- function(x) round(x, 2)\n  \n  # Filter\n  dt %>% filter(YEAR >= year_min, YEAR <= year_max, EVENT_TYPE %in% evtypes) %>%\n    # Group and aggregate\n    group_by(YEAR) %>% summarise_each(funs(sum), COUNT:CROPS_DAMAGE) %>%\n    # Round\n    mutate_each(funs(round_2), PROPERTY_DAMAGE, CROPS_DAMAGE) %>%\n    rename(\n      Year = YEAR, Count = COUNT,\n      Fatalities = FATALITIES, Injuries = INJURIES,\n      Property = PROPERTY_DAMAGE, Crops = CROPS_DAMAGE\n    )\n}\n\n#' Add Affected column based on category\n#'\n#' @param dt data.table\n#' @param category character\n#' @return data.table\n#'\ncompute_affected <- function(dt, category) {\n  dt %>% mutate(Affected = {\n    if(category == 'both') {\n      INJURIES + FATALITIES\n    } else if(category == 'fatalities') {\n      FATALITIES\n    } else {\n      INJURIES\n    }\n  })\n}\n\n#' Add Damages column based on category\n#' \n#' @param dt data.table\n#' @param category character\n#' @return data.table\n#'\ncompute_damages <- function(dt, category) {\n  dt %>% mutate(Damages = {\n    if(category == 'both') {\n      PROPERTY_DAMAGE + CROPS_DAMAGE\n    } else if(category == 'crops') {\n      CROPS_DAMAGE\n    } else {\n      PROPERTY_DAMAGE\n    }\n  })\n}\n\n#' Prepare map of economic or population impact\n#' \n#' @param dt data.table\n#' @param states_map data.frame returned from map_data(\"state\")\n#' @param year_min integer\n#' @param year_max integer\n#' @param fill character name of the variable\n#' @param title character\n#' @param low character hex\n#' @param high character hex\n#' @return ggplot\n#' \nplot_impact_by_state <- function (dt, states_map, year_min, year_max, fill, title, low = \"#d3e992\", high = \"#669900\") {\n  title <- sprintf(title, year_min, year_max)\n  p <- ggplot(dt, aes(map_id = STATE_NAME))\n  p <- p + geom_map(aes_string(fill = fill), map = states_map, colour='black')\n  p <- p + expand_limits(x = states_map$long, y = states_map$lat)\n  p <- p + coord_map() + theme_bw(base_size = 14)\n  p <- p + labs(x = \"Long\", y = \"Lat\", title = title)\n  p <- p + geom_point(x=5, y=5) + coord_fixed()\n  p + scale_fill_gradient(low = low, high = high)\n}\n\n#' Prepare plots of impact by year\n#'\n#' @param dt data.table\n#' @param dom\n#' @param yAxisLabel\n#' @param desc\n#' @return plot\n#' \nplot_impact_by_year <- function(dt, dom, yAxisLabel, desc = FALSE) {\n  impactPlot <- nPlot(\n    value ~ Year, group = \"variable\",\n    data = melt(dt, id=\"Year\") %>% arrange(Year, if (desc) { desc(variable) } else { variable }),\n    type = \"stackedAreaChart\", dom = dom, width = 650\n  )\n  impactPlot$chart(margin = list(left = 100))\n  impactPlot$yAxis(axisLabel = yAxisLabel, width = 80)\n  impactPlot$xAxis(axisLabel = \"Year\", width = 70)\n  \n  impactPlot\n}\n\n#' Prepare plot of number of events by year\n#'\n#' @param dt data.table\n#' @param dom\n#' @param yAxisLabel\n#' @return plot\n\nplot_events_by_year <- function(dt, dom = \"eventsByYear\", yAxisLabel = \"Count\") {\n  eventsByYear <- nPlot(\n    Count ~ Year,\n    data = dt,\n    type = \"lineChart\", dom = dom, width = 650\n  )\n  \n  eventsByYear$chart(margin = list(left = 100))\n  eventsByYear$yAxis( axisLabel = yAxisLabel, width = 80)\n  eventsByYear$xAxis( axisLabel = \"Year\", width = 70)\n  eventsByYear\n}\n\n#' Prepare dataset for downloads\n#'\n#' @param dt data.table\n#' @return data.table\nprepare_downloads <- function(dt) {\n  dt %>% rename(\n    State = STATE_NAME, Count = COUNT,\n    Injuries = INJURIES, Fatalities = FATALITIES,\n    Property.damage = PROPERTY_DAMAGE, Crops.damage = CROPS_DAMAGE\n  ) %>% mutate(State=state.abb[match(State, tolower(state.name))])\n}\n\n#' Upper case the first letter of a String X\n#'\n#' @param x String\n#' @return String\nsimpleCap <- function(x) {\n  s <- strsplit(x, \" \")[[1]]\n  paste(toupper(substring(s, 1,1)), substring(s, 2),\n        sep=\"\", collapse=\" \")\n}\n",
    "created" : 1434454808494.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3388867595",
    "id" : "6207371D",
    "lastKnownWriteTime" : 1434474493,
    "path" : "D:/GitHub/Developing_Data_Products_Assessments/ShinyWeatherApp/utils.R",
    "project_path" : "utils.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}